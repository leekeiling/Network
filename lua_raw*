lua_gettable和lua_settable都可以操作table。


void lua_gettable (lua_State *L, int index);
把 t[k] 值压入堆栈， 这里的 t 是指有效索引 index 指向的值， 而 k 则是栈顶放的值。

这个函数会弹出堆栈上的 key （把结果放在栈上相同位置）。 在 Lua 中，这个函数可能触发对应 "index" 事件的元方法 



void lua_settable (lua_State *L, int index);
作一个等价于 t[k] = v 的操作， 这里 t 是一个给定有效索引 index 处的值， v 指栈顶的值， 而 k 是栈顶之下的那个值。

这个函数会把键和值都从堆栈中弹出。 和在 Lua 中一样，这个函数可能触发 "newindex" 事件的元方法 


而lua_rawget和lua_rawset分别类似于lua_gettable和lua_settable




void lua_rawset (lua_State *L, int index);
类似于 lua_settable， 但是是作一个直接赋值（不触发元方法）。

void lua_rawget (lua_State *L, int index);
类似于 lua_gettable， 但是作一次直接访问（不触发元方法）。


lua_rawgeti(L,t,key)等价于
lua_pushnumber(L,key)

lua_rawget(L,t)



lua_rawseti(L,t,key)等价于

lua_pushnumber(L,key)

lua_insert(L,-2)

lua_rawset(L,t)




void lua_rawgeti (lua_State *L, int index, int n);
把 t[n] 的值压栈， 这里的 t 是指给定索引 index 处的一个值。 这是一个直接访问；就是说，它不会触发元方法。



void lua_rawseti (lua_State *L, int index, int n);
等价于 t[n] = v， 这里的 t 是指给定索引 index 处的一个值， 而 v 是栈顶的值。

函数将把这个值弹出栈。 赋值操作是直接的；就是说，不会触发元方法。

